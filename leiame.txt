Explicação do que o algoritmo faz:
    - O algoritmo constitui de duas partes: expansão e resolução.
      1. Expansão: O algoritmo busca aumentar a fronteira. Para isso, ele
                  'anda' até algum outro ponto do tabuleiro, próximo do canto
                   sudeste. Para escolher este ponto a matriz é dividida em 4
                   blocos, e o ponto escolhido é o que necessita de menos jogadas
                   para ser alcançado.
      2. Resolução: A fronteira do algoritmo é separada em interna e externa. Um
                    bloco de células será considerado fronteira externa se, ao ser
                    acoplado, aumentar a fronteira atual. Portanto, faz parte da
                    fronteira interna blocos que estão rodeados por células da cor
                    atual e/ou por células da borda (e nunca rodeados por outra cor).
                    Tendo em vista estas duas fronteiras, o algoritmo busca a cor
                    que garantirá uma maior expansão considerando a fronteira
                    externa das duas próximas jogadas. A fronteira interna é usada
                    apenas para desempate.
                    Além disso, durante a resolução sempre é feita uma busca entre
                    todas as cores para ver se alguma delas pode ser completamente
                    eliminada. Se isso ocorre, essa é uma jogada ótima, então ela
                    é sempre escolhida, independentemente das fronteiras.
Explicação de como o algoritmo o faz:
    1. Expansão: A partir do tabuleiro crio um grafo contendo caminhos mínimos do vértice
                 lider para todos os outros (mas não entre os outros, apenas com o vértice
                 como fonte do caminho). Desta forma, posso facilmente descobrir qual é o
                 vértice mais fácil de ser alcançado no canto sudeste. Então eu 'ando' até
                 o vértice no bloco sudeste do tabuleiro que eu precise de menos jogadas.
    2. Resolução: Nesta parte do algoritmo eu deixo de usar o grafo, e passo a usar a 'matriz'
                  de células normalmente. A cada jogada, sigo alguns passos (guloso olhando duas jogadas):
                  1- Define quais células são fronteira (independentemente se interna ou externa);
                  2- Das células fronteiras, separa-as em fronteira interna e externa;
                  3- Para cada cor C1 possível, 'finge' pintar o mapa com a cor C1 e faz tudo novamente,
                     escolhendo uma outra cor C2, tal que C2 seja a cor que pinta mais células da fronteira
                     externa para cada C1.
                  4- Escolhe C1 tal que o número de células pintadas com C1 e C2 seja o maior possível. Se
                     o número de células da fronteira externa empatar entre duas combinações diferentes de
                     cores, a fronteira interna é usada para desempate.

Explicação dos arquivos:

    Todos os seguintes arquivos possuem o respectivo header, com cabeçalhos de funções, defines, etc.

    ia.c --> Contém as principais funções pra rodar o programa (chama todas as outras funções e imprime o resultado final);
    fronteira.c --> Contém funções que tratam das fronteiras: identificar células na fronteira, definir se é fronteira interna
                    ou externa e, tendo as fronteiras definidas, descobrir qual é a 'melhor' jogada a se fazer.
    mapa.c --> Contém funções que auxiliam na operação do mapa, como: inicializar algumas variáveis, imprimir o mapa, pintar ele,
               pintar 'de mentirinha' (para poder observar a próxima jogada sem estragar o mapa), allocar e desallocar memória,
               ver se determinada célula faz parte da borda, ver se o tabuleiro foi resolvido.
    grafo.c --> Contém funções que geram e usam um grafo auxiliar para o tabuleiro.
    utils.c --> Contém funções genéricas que auxiliam as outras, tais como: funções genéricas para grafos (allocar e desallocar
                grafo, vértice e aresta, imprimir grafo), funções genéricas de listas (allocar, desallocar, inserir, remover,
                imprimir). Possui também funções de comparação para ordenar vetor. Além disso, contém definições de estruturas
                de dados.

Entrada: Número de linhas, colunas e cores e, em seguida, um mapa.

Saída: O número de jogadas necessárias e, em seguida, a sequência de jogadas do algoritmo.

Estruturas de dados:

    Grafo, vértice e aresta: juntos compõe um grafo.
    Grafo --> Formado por uma lista de vértices, e possui um vértice chamado 'lider', que
              é o vértice que representa o bloco de células do canto superior esquerdo.
    Vértice --> bloco de células da mesma cor. Elems indica quantas células existem no vértice.
    Aresta --> Indica vizinhança entre dois vértices. Vs simboliza o vértice de saída, vc o
               vértice de chegada. Nem todas as arestas são incluídas; apenas as que formam o
               menor caminho. Em outras palavras, o grafo é um grafo de menores caminhos, sendo
               que todos os caminhos começam no vértice líder e acabam em todos os outros vértices.
    struct grafo {
        int len;
        char *nome;
        lista v;
        vertice lider;
    };

    struct vertice {
        int *i, *j, cor, id, elems, d;
        lista saida, entrada;
    };

    struct aresta {
        vertice vs, vc;
        long int peso;
    };

    Avaliador --> Auxilia na contagem de células que podem ser eliminados. Essa estrutura é utilizada
                  para decidir se uma cor pode ser completamente eliminada e também é usada para
                  escolher qual a melhor jogada, considerando também a próxima jogada.
    struct avaliador {
        int cor, n_int, n_ext;
    };

    Lista e no: juntos compõe uma lista.
    Lista --> possui algumas propriedades e sabe quem é o nó inicial (primeiro).
    No --> Uma estrutura que possui um conteúdo qualquer (void *) e um apontador para o próximo nó da lista.
           Quando o próximo nó é NULL, a lista chegou ao fim.
    struct no {
        void *conteudo;
        no proximo;
    };
    struct lista {
        unsigned int tamanho;
        int padding;
        no primeiro;
    };

    Tmapa --> Representa o tabuleiro. Possui algumas informações a respeito deste (nlinhas, ncolunas, ncores e tam)
              e um vetor de celulas, que é usado como uma matriz. Ele é implementado como um vetor pois garante que
              a memória fique contígua, aproveitando melhor a memória cache. Para facilitar utilizar esse vetor, foi
              criada uma função chamada ID, que recebe como parâmetro dois inteiros (i,j) e retorna a posição x no
              vetor que corresponderia à posição i,j caso esta estrutura fosse uma matriz. Desta forma, é possível
              acessar o vetor da forma: m->mapa[ID(i,j)], que seria equivalente a m->mapa[i,j] caso este fosse uma
              matriz.
    Celula --> Um elemento do tabuleiro. Possui uma cor, um vértice (o vértice que representa o bloco
               de cor em que a célula está localizada) e algumas propriedades que servem como armazenadores
               temporários, para auxiliar as funções.
    struct tmapa {
        int nlinhas;
        int ncolunas;
        int ncores;
        int tam;
        celula *mapa;
    };
    struct celula {
        int cor, counted, status, counted2, pintado;
        vertice v;
    };
